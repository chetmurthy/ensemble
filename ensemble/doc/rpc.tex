%*************************************************************%
%
%    Ensemble, 1.10
%    Copyright 2001 Cornell University, Hebrew University
%    All rights reserved.
%
%    See ensemble/doc/license.txt for further information.
%
%*************************************************************%
\section{The Ensemble client/server interface (by Robbert vanRenesse)}

Ensemble provides client/server interfaces.  We document in this section the
interface as provided for OCaml programmers, but the interfaces are also available as
C interfaces (through the use of the Camouflage tool).  Clients do not have to load
Ensemble to be able to talk to an Ensemble service.  Also, the server interface is
available independent of Ensemble if so desired.  Replicated servers will choose to
use Ensemble.  The Ensemble client/server (ECS) interface is scalable: since it uses
TCP as its communication mechanism, clients can invoke services from all over the
world.

\subsection{Linking}

All programs that use ECS should be linked with \sourcecode{lib/librpc.cma} and one
of the \sourcecode{lib/hsys\_*.cmo's}, depending on the environment.  For UNIX,
\sourcecode{hsys\_unix.cmo} is appropriate, whereas for Windows,
\sourcecode{hsys\_ntunix.cmo} or \sourcecode{hsys\_ntskt.cmo} can be used.

\subsection{Initialization}

All ECS processes have to open the Rpc module.  It makes available the Sockio module
in which the ECS procedures live.  To use ECS from an Ensemble process, the following
command needs to be used for initialization:

\begin{codebox}
  Sockio.ensemble_register (Alarm.add_sock alarm) (Alarm.rmv_sock alarm)
\end{codebox}
where \mlval{alarm} is typically returned by \mlval{Transport.alarm}.  Ensemble
programs also have to invoke \mlval{Sockio.sweep()} regularly (say every two seconds)
to keep things rolling along.  To use ECS without Ensemble, the following command
should be executed instead:
\begin{codebox}
  Sockio.sockio_register()
\end{codebox}

In this case, the server needs to run a main loop that typically looks like this:
\begin{codebox}
  while true do
    Sockio.select 2.0
  done
\end{codebox}
(In this case, the \mlval{select} wakes up every two seconds, and
automatically invokes \mlval{sweep}.)

\subsection{Creating an RPC server}

An RPC server would then use

where \mlval{port} is an integer giving the TCP port that is used for the server
(should typically be above 1000, or 0 if you don't care), and \mlval{eval rid cmd} is
a function that is invoked for each request message (cmd) that arrives.  The function
is invoked with a Request Identifier (rid) which is used for responding to requests.
Two kinds of responses are possible:
\begin{codebox}
  Sockio.response rid reply;
  Sockio.except rid description;
\end{codebox}

The first sends a normal response back to the client.  The second sends an
exceptional response.  (A third one is in the making allowing for redirecting
requests to different servers.)  The following is a simple example of a file server
that supports read and write commands:
\begin{codebox}
  open Rpc
  
  type file_cmd
    = FILE_READ of string
    | FILE_WRITE of string * string
  
  let eval rid cmd =
    let dispatch = function
      | FILE_READ name ->
          Sockio.response rid (File.read name)
      | FILE_WRITE name data ->
          File.write name data;
          Sockio.response rid ()
    in
    try
      dispatch cmd
    with
      | Sys_error descr ->
          Sockio.except rid descr
      | _ ->
          Sockio.except rid "something went wrong"
\end{codebox}
(Typically, the type declaration would be in a separate \mlval{.mli} file for use by
both the client and the server.)

An Ensemble server using the Appl interface would possibly queue commands for later
use, and invoke the \mlval{async()} downcall to generate an upcall that dequeues the
command and handles it.

For advanced users: the Request Identifier contains an identifier that may be used in
a replicated service to detect retransmissions of the same request.  This identifier
may be retrieved using the function \mlval{Sockio.mid\_of\_rid}.  A printable version
of the result may be invoked by subsequently calling \mlval{Sockio.string\_of\_mid}.

\subsection{Creating an RPC Client}

A client first needs to generate a handle for the server:
\begin{codebox}
   let file_svr = Sockio.bind_to_service "file"
\end{codebox}

If you are running the Ensemble White Pages service, this is all that need be done to
contact the file service.  If you don't want to run the White Pages service, this
command need be followed by one or more commands to specify the location of the
server or servers:
\begin{codebox}
   Sockio.add_to_service file_svr "snotra.cs.cornell.edu" port;
   Sockio.add_to_service file_svr "tumeric.cs.cornell.edu" port;
\end{codebox}

When an RPC is done, any of these services will be contacted.  Services that are not
currently reachable will be ignored.

The client can now invoke RPCs using the following command:
\begin{codebox}
  Sockio.rpc file_svr (FILE_READ "test") success failure
\end{codebox}

This commands sends the given command to the file server, and invokes the command
\mlval{success reply} if the server invokes \mlval{Sockio.response reply}, or
alternatively the command \mlval{failure description} if the server invokes
\mlval{Sockio.except description}.  Unfortunately, due to some typing difficulties,
both \mlval{reply} and \mlval{description} are of type \mlval{Obj.t}, and have to be
cast to the proper type using \mlval{Obj.magic}.  For example, to print the file
"test", you may write the following:
\begin{codebox}
  let complete data =
    printf "\%s" (Obj.magic data); flush stdout
  and abort descr =
    printf "Problem: \%s" (Obj.magic descr); flush stdout
  in
  Sockio.rpc file_svr (FILE_READ "test") complete abort
\end{codebox}

RPCs can not fail because of problematic network connections or faulty servers.
\mlval{Sockio.rpc} will retransmit the request to its servers until it receives a
response, be it positive or negative.  It is therefore possible that a request gets
executed multiple times, but as mentioned in the previous section, the servers can
filter out retransmissions.  In the future, we may add a time-out facility to RPCs.

Also, RPCs are non-blocking, and the responses are returned through upcalls.  You can
use OCaml threads to remedy this.  Alternatively, you can use Robbert's Goal-Oriented
Programming Style (as will be described somewhere soon) to deal effectively with an
upcall driven environment.

\subsection{Non-RPC clients and servers}

ECS doesn't enforce an RPC style on clients and servers.  Alternatively, just a
connection can be set up over which messages may be transmitted.  The server, in
that case invokes

\begin{codebox}
  Sockio.server "Name" port callback
\end{codebox}

Each time a connection with a client is established, callback is invoked with two
function arguments.  The first is the send routine for this connection, which takes a
message argument (of arbitrary type).  The second is a close routine which can close
the connection.  The callback has two return a tuple with two functions.  The first
is a routine that may be used to deliver messages (it takes a message argument).  The
second is a routine that is invoked when a failure occurs.

A client can set up a connection to a server using the following:
\begin{codebox}
  Sockio.client "Name" callback
\end{codebox}

The callback is very similar to the server's one, except that the failure routine
returns a boolean value.  If true, the connection is reestablished (perhaps with a
different server).  If false, the connection remains closed.
