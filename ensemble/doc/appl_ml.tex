%*************************************************************%
%
%    Ensemble, 1.10
%    Copyright 2001 Cornell University, Hebrew University
%    All rights reserved.
%
%    See ensemble/doc/license.txt for further information.
%
%*************************************************************%
\section{\ensemble\ ML Application Interface}
\label{section:applintf}
\todo{add example handlers from mtalk}

We present a simple interface for building single-group applications.  This
interface is intended to make small applications easy to build, and to protect
users from complications in the internals of the system.

The interface is implemented as a set of callbacks the application provides to
\ensemble.  The application is notified through these callbacks (in a similar
fashion to callbacks with Motif widgets) of events that occur in the system,
such as message receipts and membership changes.

The interface for a member of a group is always in one of two states,
\emph{blocked} or \emph{unblocked}.  While unblocked, only the
\mlval{recv\_send}, \mlval{recv\_cast}, and \mlval{heartbeat} callbacks are
enabled.  This is the normal state of the system.  While blocked, another set
of callbacks can occur that notify the application of membership changes in the
group.  In addition there are callbacks that notify the application of
transitions between the blocked and unblocked states.

Messages are sent by returning from these callbacks lists of actions to
take.  An action is usually a message send: either a \mlval{Cast} (group
broadcast) or a \mlval{Send} (point-to-point message).  Thus, messages are
delivered by callbacks from \ensemble\ and further messages are sent by
returning values from these callbacks.

\subsection{Compilation}
Compiling ML applications is easy.  You can use \sourcedemo{Makefile} as a
skeleton for your own applications.

\subsection{Interface Definition and Initialization}
Below is the full ML interface type definition for the application
interface described here.  A group member is initialized by creating an
interface record which defines a set of callback handlers for the
application.  This is then passed to one of the \ensemble\ stack initialization
functions exported by \sourcecode{appl/appl.mli}.

\begin{codebox}
(* Some type aliases.
 *)
type rank	= int
type view 	= Endpt.id list
type mergers 	= Endpt.id list
type contact 	= Endpt.id
type origin 	= rank
type dests 	= rank array

type ('cast_msg, 'send_msg) action =
  | Cast of 'cast_msg
  | Send of dests * 'send_msg
  | Leave
  | XferDone
  | Protocol of Proto.id
  | Migrate of Addr.tl
  | Timeout of Time.t		        (* not supported *)
  | Dump
  | Block of bool			(* not for casual use *)
\end{codebox}
\begin{codebox}
(* APPL_INTF.full: The record interface for applications.  An
 * application must define all the following callbacks and
 * put them in a record.
 *)

type (
  'cast_msg,
  'send_msg,
  'merg_msg,
  'view_msg
) full = \{

  recv_cast             : origin -> 'cast_msg ->
    ('cast_msg,'send_msg) action array ;

  recv_send             : origin -> 'send_msg ->
    ('cast_msg,'send_msg) action array ;

  heartbeat_rate        : Time.t ;

  heartbeat             : Time.t ->
    ('cast_msg,'send_msg) action array ;

  block                 : unit ->
    ('cast_msg,'send_msg) action array ;

  block_recv_cast       : origin -> 'cast_msg -> unit ;
  block_recv_send       : origin -> 'send_msg -> unit ;
  block_view            : View.state -> (rank * 'merg_msg) list ;
  block_install_view    : View.state -> 'merg_msg list -> 'view_msg ;
  unblock_view          : View.state -> 'view_msg ->
    ('cast_msg,'send_msg) action array ;

  exit                  : unit -> unit
\}
\end{codebox}

\subsection{Actions}
Some callbacks allow a (possibly empty) array of actions to be 
returned.  There are 4 different kinds of actions:
\begin{description}
\item
[Cast(msg)] : Causes \mlval{msg} to be broadcast to the group.
\item
[Send(dests,msg)] : Causes \mlval{msg} to be sent to a subset of the group
specified in \mlval{dests}.  \mlval{dests} is an array of ranks, but most
protocol stacks only support sends with a single destination.  In order to send
to multiple destinations in a single action, some layer that supports subset
broadcasts must be in the stack.
\item
[Leave] : Causes the member to leave the group.  There should always
be at most one \mlval{Leave} action returned in an action array.
\item
[XferDone] : Signals that this member has completed its state transfer.  If a
state transfer layer is in the protocol stack, this will trigger a new
non-state transfer view after all members have taken an \mlval{XferDone}
action.
\item
[Protocol(protocol)] : Requests a protocol switch.  If the stack supports
protocol switches, a new view will be triggered.
\item
[Dump] : Causes some debugging output to be printed by the stack in use.
The output depends greatly on the protocol stack.
\end{description}

\subsection{Normal Operation: Unblocked}
Under normal operation only the following callbacks are called.
\mlval{recv\_cast} is called when a broadcast message has been received.  The
callback is made with the origin of the sender and the message.
\mlval{recv\_send} is called when a point-to-point message has been received.
The callback is made with the origin of the sender and the message.
\mlval{heartbeat} is regularly called by \ensemble\ when the application is
unblocked.  The expected rate of heartbeats is specified through the
\mlval{heartbeat\_rate} field of the interface record.  The return values for
all of these callbacks is an action array.
\begin{codebox}
  recv_cast             : origin -> 'cast_msg ->
    ('cast_msg,'send_msg) action array ;

  recv_send             : origin -> 'send_msg ->
    ('cast_msg,'send_msg) action array ;

  heartbeat_rate        : Time.t ;

  heartbeat             : Time.t ->
    ('cast_msg,'send_msg) action array ;
\end{codebox}

\subsection{Asynchronous operation}
The application can only send messages when handling a callback.  Under some
circumstances (such as when receiving input from another source), it is necessary to
send messages immediately rather than waiting for the next regularly scheduled
heartbeat to occur.  Call the function \mlval{Appl.async} with the group and endpoint
of the group.  This returns a function that can be called whenever an immediate
hearbeat is desired.
\note{This replaces the previous \mlval{heartbeat\_now} callback.}
\begin{codebox}
  let async = Appl.async (group,endpt) in
  async ()
\end{codebox}

\subsection{Blocking}
When a membership change is about to happen, the group blocks and only the
``block'' callbacks occur until the group is unblocked by the installation
of a new view.  A member is notified of the blocking with a block callback:
\begin{codebox}
  block                 : unit ->
    ('cast_msg,'send_msg) action array ;
\end{codebox}

\subsection{Receiving messages while blocked}
While a group is blocked, cast and send messages are delivered through the
following callbacks.  The arguments are the same as above, but callbacks cannot
initiate new actions.
\begin{codebox}
  block_recv_cast       : origin -> 'cast_msg -> unit ;
  block_recv_send       : origin -> 'send_msg -> unit ;
\end{codebox}

\subsection{New views}
When \ensemble\ installs a new view of the group, the application goes through a
simple protocol in order to transfer state between members.  This begins by
\ensemble\ calling the \mlval{block\_view} callback with the state of the new view
(see below).  This callback returns a list of pairs.  Each pair is a rank and a state
for that member of the group.  Each member can return a pair just for itself, or
members can specify the states of other members.  When non-empty, these lists are
sent back to the coordinator.  The coordinator collects them, waiting until it has a
state from every member.  If there is a failure, then the whole process may begin
again with a \mlval{block\_view}.

When the coodinator has all of the states, the \mlval{block\_install\_view} callback
is called, again with the view state and also with a list of states, one for each
member in the group.  The ranks are not included with the states, as the states are
ordered according to the view.  The callback then returns a common state that will be
sent to all the members.  Every member will then receive an \mlval{unblock\_view}
callback with the view state and the state returned by the coordinator.  At this
point, each member is unblocked and may begin sending messages again.
\begin{codebox}
  block_view            : View.state -> (rank * 'merg_msg) list ;
  block_install_view    : View.state -> 'merg_msg list -> 'view_msg ;
  unblock_view          : View.state -> 'view_msg -> 
    ('cast_msg,'send_msg) action array ;
\end{codebox}

\input{view_state}

\subsection{Exit notice}
Called when the member has left the group (through a previous \mlval{Leave}
action).  This is the last callback the group member will receive.
\begin{codebox}
  exit                  : unit -> unit ;
\end{codebox}

\input{property}

In order to set the properties used by an application, you would use the
following code:
\begin{codebox}
  (* Choose default view state.
   *)
  let vs = Appl.default_info "my-appl" in

  (* Select desired properties.
   *)
  let properties = [ (* list of properties *) ] in

  (* Choose corresponding protocol stack.
   *)
  let proto_id = Property.choose properties in

  (* Set proto_id of the view state record.
   *)
  let vs = View.set vs [Vs_proto_id proto_id] in

  (* Configure the application
   *)
  Appl.config my_interface vs ;
\end{codebox}

As described in the reference manual, each of these protocols are derived by
combining a set of protocol layers together to get a full protocol stack with
application-level properties.  Anyway, here we describe the behavior of the
\mlval{vsync} protocol stack.
\begin{itemize}
\item
The first callback a protocol stack receives is an \mlval{unblock\_view} with a
singleton view.
\item
All members in the same partition of a group receive the same \mlval{View.state}
records (excepting the \mlval{rank} field, of course).
\item
\mlval{Send} messages are delivered reliably and in FIFO order.  It is an error
for a member to send a message to itself.
\item
\mlval{Cast} messages are delivered reliably and in FIFO order.  FIFO order for
\mlval{Cast} messages means that members receive the messages in the order they
were sent by the sender.  \mlval{Cast} messages are usually not delivered to
the sender (the primary exceptions are stacks with total-ordering layers in
them).
\item
There is no ordering relationship \emph{between} \mlval{Send} and \mlval{Cast}
messages.
\item
Messages are delivered in the same view they were sent in (the protocol stack
``blocks'' so that the protocols can flush all the current messages out of the system
before advancing to the next view).
\item
\mlval{Cast} messages are delivered atomically.  This means that either all
members (excepting the sender) or none will receive a \mlval{Cast} message.  If
the sender of a \mlval{Cast} message fails, other members who received the
message will retransmit it for the failed member.  When there is more than one
member in a group, a \mlval{Cast} message may be delivered to no members only
if the sender fails.
\item
All members that receive the same consecutive views (they get the same
\mlval{block\_view} upcalls) will have delivered the same set of \mlval{Cast}
messages between the upcalls (but not necessarily in the same order).  Thus views can
be considered as synchronization points where all members agree on what has been done
so far.
\end{itemize}

\subsection{Initializing \ensemble\ Applications}

This is a description of how simple applications are initialized with \ensemble.  The
source code presented here is extracted from the \mlval{mtalk} demo, which is
distributed with \ensemble.  The source can be found in \sourcedemo{mtalk.ml} which
compiles and links with the \ensemble\ library to form the \sourcedemo{mtalk}
executable.

An application consists of two parts, initialization and an interface.  The
initialization involves setting up \ensemble\ and the communication framework.
An interface consists of a set of callback handlers that manage application
events that \ensemble\ generates for messages and membership changes.  The
initialization code tends to be similar across applications, and the handlers
tend to contain most of the application-specific functionality.  We present a
sample set of initialization code, which can easily be adapted for other simple
applications.  We do not describe the callback handlers here; they are
described in section~\ref{section:applintf}.  For specific examples, see
\sourcedemo{mtalk.ml} and \sourcedemo{ring.ml}.

\begin{codebox}
let run () =
  (*
   * Parse command line arguments.
   *)
  Arge.parse [
    (*
     * Extra arguments can go here.
     *)
  ] (Arge.badarg name) "mtalk: multiperson talk program" ;

  (*
   * Get default transport and alarm info.
   *)
  let view_state = Appl.default_info "mtalk" in
  let alarm = Alarm.get () in
\end{codebox}
The initialization must do several things, all of which can be contained in a
single function, as shown here with the function \mlval{run}.  First parse the
command-line arguments as is done above.  In addition to arguments provided by
the applicatoin, this parses the standard \ensemble\ arguments.  Then,
\mlval{default\_info} is called.  This initializes a \mlval{View.state} record
(which contains all the information other modules need to initialize your
application).

\begin{codebox}    
  (*
   * Choose a string name for this member.  Usually
   * this is "userlogin@host".
   *)
  let name =
    try
      let host = gethostname () in

      (* Get a prettier name if possible.
       *)
      let host = string_of_inet (inet_of_string host) in
      sprintf "%s@%s" (getlogin ()) host
    with _ -> view_state.name
  in

  (*
   * Initialize the application interface.
   *)
  let interface = intf view_state name alarm in
\end{codebox}    
Next we initialize the interface record that contains the
application's handlers and which does the actual work of the
application.  How the interface is initialized is application
dependent.  For example, \mlval{interface} will usually require
several arguments.  In the \mlval{mtalk} application, the interface
takes the endpoint identifier of the application and a string name to
use for this member of the talk group.  Other applications will use
different arguments.

\begin{codebox}    
  (*
   * Initialize the protocol stack, using the interface and
   * view state chosen above.  
   *)
  Appl.config interface view_state ;
\end{codebox}    
The code above initializes the protocol stack.  In this case we use
the \mlval{vsync} protocol properties, which provide FIFO,
virtually-synchronous communication and an automatic merging facility
for healing partitions.  There are several different sets of
properties by the \sourceappl{property.mli} module, each of which
provides different properties or performance characteristics (for
more information about properties, see section~\ref{sec:properties}).

\begin{codebox}    
  (*
   * Enter a main loop
   *)
  Appl.main_loop ()
  (* end of run function *)


(* Run the application, with exception handlers to catch any
 * problems that might occur.
 *)
let _ = Appl.exec ["mtalk"] run
\end{codebox}    
The initialization is complete and we enter a main loop.  The main
loop never returns.  The final code calls the \mlval{run} function
with some standard exception handlers to catch any exceptions that
should not, but may, occur.

This is all that is required for initializing simple, single-group Ensemble
applications.  
%The main part of the work required for an application is in
%building the handlers for sending and receiving messages, described in the
%following section.
