<!-- File: Maestro_CSX.htm -->
<!-- Author: Alexey Vaysburd -->
<!-- Contents:  Description of Maestro_CSX class (clients/servers + xfer) -->
<!-- Created: September 1995 -->
<!-- Updated: Feb 1997 -->

<html>

<head>
<title>Maestro Open Toolkit:  Clients/Servers + State Transfer Interface</title>
<link rev="made" href="mailto:alexey@cs.cornell.edu (Alexey Vaysburd)">
</head>

<BODY TEXT="#000000" BGCOLOR="#FCD5AD" LINK="#0000FF" VLINK="#551A8B" ALINK="#FF0000">
<TABLE WIDTH="800" >
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH="100"><IMG SRC="maestro-logo.jpg" VSPACE=20 HSPACE=20 HEIGHT=105 WIDTH=70 ALIGN=LEFT></TD>

<TD WIDTH="500" BORDER="0">
<H1>Maestro Open Toolkit:  Clients/Servers + State Transfer Interface</H1>
</TD>
</TR>
</TABLE>
</h1>

This document is a part of online 
<a href="http://www.cs.cornell.edu/Info/Projects/Ensemble/index.htm">
Ensemble</a> documentation, under 
<a href="Maestro.htm">Maestro Open Toolkit</a>.
<hr>
<p>
The 

<a href="Maestro_Xfer.htm">state-transfer protocol of Maestro</a> 

is implemented in the 

<a href="Maestro_ClSv.htm#Maestro_ClSv"><tt>Maestro_ClSv</tt></a> 

class. The interface to state transfer provided in 

<a href="Maestro_ClSv.htm#Maestro_ClSv"><tt>Maestro_ClSv</tt></a>

is, however, 
at a low level, and leaves some details to be taken care of by the application.
In particular, a joining server has to choose an old server from which to 
request the state, and it has to replay the request should the chosen server crash 
during state transfer.  Also, a joining server may need to terminate state
transfer and possibly restart it in some scenarios, which makes it necessary
to be able to distinguish between different state-transfer transactions --
all of which would have to be implemented at the application level if using 
<a href="Maestro_ClSv.htm#Maestro_ClSv"><tt>Maestro_ClSv</tt></a>
directly.  Alternatively, the application can be built above the
<a href="Maestro_CSX.htm#Maestro_CSX"><tt>Maestro_CSX</tt></a> 
class, which provides additional state-transfer 
functionality behind a higher-level interface.

<h4>Index of State Transfer Callbacks/Downcalls:</h4>
<dir>
<li><a href="Maestro_CSX.htm#resetState"><tt>resetState</tt></a>
<li><a href="Maestro_CSX.htm#stateTransfer_Callback"><tt>stateTransfer_Callback</tt></a>
<li><a href="Maestro_CSX.htm#getState_blocking"><tt>getState</tt></a> (blocking)
<li><a href="Maestro_CSX.htm#getState_nonblocking"><tt>getState</tt></a> (non-blocking)
<li><a href="Maestro_CSX.htm#askState_Callback"><tt>askState_Callback</tt></a>
<li><a href="Maestro_CSX.htm#sendState"><tt>sendState</tt></a>
<li><a href="Maestro_CSX.htm#gotState_Callback"><tt>gotState_Callback</tt></a>
<li><a href="Maestro_CSX.htm#xferCanceled_Callback"><tt>xferCanceled_Callback</tt></a>
<li><a href="Maestro_CSX.htm#xferDone"><tt>xferDone</tt></a>
</dir>

<h4>Code Examples:</h4>
<dir>
<li><a href="sync-xfer-example.htm">Blocking (synchronous) state transfer</a> (for 
	<a href="Maestro_Overview.htm#Threading_issues">multi-threaded mode</a> only).
<li><a href="async-xfer-example.htm">Non-blocking (asynchronous) state transfer</a>
</dir>

<h2>
<a name="Maestro_CSX">
<hr>Maestro_CSX
</a>
</h2>

<tt>Maestro_CSX</tt> (a subclass of 
<a href="Maestro_ClSv.htm#Maestro_ClSv"><tt>Maestro_ClSv</tt></a>) 
provides a higher-level interface to 
state transfer.  

<p>
It may happen (as a result of group partitioning and merging) that state transfer will be 
(re)started more than once at a given server.  On the other hand, a state transfer may be 
terminated before completion (if all old servers crash or partition away during state
transfer). 
Since it is possible that a new state transfer will be started before the 
completion of a previous one, <tt>Maestro_CSX</tt> assigns a unique ID to every state 
transfer transaction so that the application can distinguish between them.

<p>
When state transfer needs to be (re)started, the
<a href="Maestro_CSX.htm#stateTransfer_Callback"><tt>stateTransfer_Callback</tt></a>
method is invoked.  If Maestro is run in the 

<a href="Maestro_Overview.htm#Threading_issues">
multi-threaded mode</a>,

<tt>stateTransfer_Callback</tt> is called in a separate thread.  However, in the 

<a href="Maestro_Overview.htm#Threading_issues">
single-threaded mode</a>

<tt>stateTransfer_Callback</tt> is invoked in the same (Ensemble) 
thread as all other callbacks.

<p>
A joining server can request (a portion of) the state form an old server with a 
<tt>getState</tt> downcall.  There are two versions of <tt>getState</tt>, a
<a href="Maestro_CSX.htm#getState_blocking">
blocking
</a>
and a 
<a href="Maestro_CSX.htm#getState_nonblocking">
non-blocking
</a> 
one.  In the multi-threaded mode, both versions of <tt>getState</tt> can be used.  
However, the non-blocking version of 
<a href="Maestro_CSX.htm#getState_nonblocking">
<tt>getState</tt>
</a>
is the only choice when running Maestro in the single-threaded mode.

<p>
A call to <tt>getState</tt> made at a joining server results in an invocation
of the 

<a href="Maestro_CSX.htm#askState_Callback">
<tt>askState_Callback</tt> 
</a>

method at a normal ("old") server, which should eventually respond 
by sending a state message
to the joining server with a call to the

<a href="Maestro_CSX.htm#sendState">
<tt>sendState</tt>
</a> function. 

When the joining
server receives the state message, the corresponding call to <tt>getState</tt> 
returns (if the synchronous/blocking version of <tt>getState</tt> was called) or the 

<a href="Maestro_CSX.htm#gotState_Callback">
<tt>gotState_Callback</tt>
</a>

is invoked (in the asynchronous/non-blocking case). 

<p>
If a state-transfer transaction is terminated while the joining server is still 
waiting for a state message from an old server, the call to <tt>getState</tt> will
return with the abnormal-termination status (in case of a blocking call), or else
the 

<a href="Maestro_CSX.htm#xferCanceled_Callback">
<tt>xferCanceled_Callback</tt>
</a>
method will be invoked (in case of a non-blocking call).

<p>
Once the joining server has completed state transfer, it should invoke the

<a href="Maestro_CSX.htm#xferDone">
<tt>xferDone</tt>
</a>

method.  Following that, a new view will eventually be installed, where the joining
server will be included in the list of "normal" servers.

<p>
The interface to the state transfer functionality provided by <tt>Maestro_CSX</tt>
is described in sections below.
<br>
<p>

<h4>
<a name="resetState"><hr>resetState</a></h4>

<pre>		void resetState();</pre>

<li>This method is implemented as a no-op in the <tt>Maestro_CSX</tt> class.  It can be
overloaded to do application-specific state initialization at the beginning of
executution and during (re)start of state-transfer.

<p>
<h4>
<a name="stateTransfer_Callback"><hr>stateTransfer_Callback</a></h4>

<pre>		void stateTransfer_Callback(Maestro_XferID &xferID);</pre>

<li>This callback is invoked at a joining server when 
state transfer is (re)started.  It is invoked in a separate thread if Maestro is 
running in 
the 

<a href="Maestro_Overview.htm#Threading_issues">multi-threaded mode</a>, 

and in the same (Ensemble) thread if Maestro is in the 

<a href="Maestro_Overview.htm#Threading_issues">single-threaded mode</a>.  

The argument, <tt>xferID</tt>, identifies the  
state transfer transaction. The default implementation of <tt>stateTransfer_Callback</tt> 
only invokes 

<a href="Maestro_CSX.htm#xferDone"><tt>xferDone(xferID)</tt></a>

(which completes the state transfer), and returns.  The <tt>stateTransfer_Callback</tt>
method should be overloaded in a subclass of <tt>Maestro_CSX</tt> to implement
application-specific state transfer functionality. 

<p>

Upon completion of state transfer, the application must notify Maestro by calling 
<a href="Maestro_CSX.htm#xferDone"><tt>xferDone</tt></a> with the same value of 
<tt>xferID</tt> as the one passed to the corresponding invocation of 
<tt>stateTransfer_Callback</tt>.

<p>
<h4>
<a name="getState_blocking"><hr>getState (blocking version)</a></h4>

<pre>		void getState(Maestro_XferID &xferID, 
			      Maestro_Message &requestMsg,
			      /*OUT*/ Maestro_Message &stateMsg,
			      /*OUT*/ Maestro_XferStatus &xferStatus);</pre>

<li>This blocking method is invoked by a joining server (usually from within 
<a href="Maestro_CSX.htm#stateTransfer_Callback"><tt>stateTransfer_Callback</tt></a>) 
to request a portion of the state from one of normal (old) servers.  

The application can make as many calls to <tt>getState</tt> as necessary. 
However, the <tt>getState</tt> function <em>is not reentrant</em>.
Also, in all invocations of <tt>getState</tt>, the value of the <tt>xferID</tt> 
argument must be equal to the value passed to the corresponding invocation of  
<tt>stateTransfer_Callback</tt>.  The <tt>requestMsg</tt> argument contains the request 
message specifying which portion of the state is being requested.  If <tt>getState</tt> 
returns with a success value (see below), 
<tt>stateMsg</tt> contains the reply message with the requested part of 
the state in it.  

<p>
When a call to <tt>getState</tt> returns, the value of the <tt>xferStatus</tt> argument
will be equal to <tt>MAESTRO_XFER_OK</tt> if the state request has succeeded, and 
<tt>MAESTRO_XFER_TERMINATED</tt> if the transfer has been prematurely 
terminated (usually because of a group merge or a total failure/partitioning away of all normal 
servers).  If state transfer has been terminated, <tt>stateTransfer_Callback</tt> 
should return without further attempts to get the state.

<p>
The blocking version of <tt>getState</tt> can only be used when Maestro is running in the
<a href="Maestro_Overview.htm#Threading_issues">multi-threaded mode</a>.
In the 
<a href="Maestro_Overview.htm#Threading_issues">single-threaded mode</a>, the 
<a href="Maestro_CSX.htm#getState_nonblocking">non-blocking version of <tt>getState</tt></a>
must be used.

<p>
<h4>
<a name="getState_nonblocking"><hr>getState (non-blocking version)</a></h4>

<pre>		void getState(Maestro_XferID &xferID, 
			      Maestro_Message &requestMsg,
			      /*OUT*/ Maestro_XferStatus &xferStatus);</pre>

<li>This non-blocking method is invoked by a joining server 
to request a portion of the state from one of normal (old) servers.  
The <tt>requestMsg</tt> argument contains the request 
message specifying which portion of the state is being requested. 
Following a call to <tt>getState</tt>, the 
<a href="Maestro_CSX.htm#gotState_Callback"><tt>gotState_Callback</tt></a> method
will eventually be invoked when the requested portion of the state has been 
successfully received from an old server.  However, if the state-transfer 
transaction is canceled (for any reasons) before the state is received, the
<a href="Maestro_CSX.htm#xferCanceled_Callback"><tt>xferCanceled_Callback</tt></a>
method will be invoked instead of <tt>gotState_Callback</tt>.

<p>
The application can make as many calls to <tt>getState</tt> as necessary. 
However, the <tt>getState</tt> function <em>is not reentrant</em>.  Furthermore, 
after a call to (non-blocking) <tt>getState</tt> has been made, a 
subsequent invocation of the function can only be made after the portion 
of the state requested in the previous call to <tt>getState</tt> 
has been received (with a matching invocation of the <tt>gotState_Callback</tt> method).

<p>
Also note that in all invocations of <tt>getState</tt>, the value of the <tt>xferID</tt> 
argument must be the ID of the current state-transfer transaction (which is the value of
the <tt>xferID</tt> argument passed to the corresponding invocation of  
<tt>stateTransfer_Callback</tt>).  

<p>
The non-blocking (asynchronous) version of <tt>getState</tt> can be used when Maestro 
is running in either
<a href="Maestro_Overview.htm#Threading_issues">multi-threaded mode</a> or 
<a href="Maestro_Overview.htm#Threading_issues">single-threaded mode</a>, and is the only
option in the latter case.  However, in the multi-threaded mode, the 
<a href="Maestro_CSX.htm#getState_blocking">blocking (synchronous) version of 
<tt>getState</tt></a> can also be used.

<p>
<h4>
<a name="askState_Callback"><hr>askState_Callback</a></h4>

<pre>		void askState_Callback(Maestro_EndpID &origin, 
				       Maestro_XferID &xferID,
				       Maestro_Message &requestMsg);</pre>

<li>This callback method is invoked at a normal (old) server when a state request from a 
joining server arrives (as a result of calling the 
<a href="Maestro_CSX.htm#getState_blocking">blocking</a> or
<a href="Maestro_CSX.htm#getState_nonblocking">non-blocking</a>
<tt>getState</tt> function by the joining server).  
The <tt>origin</tt> argument is the endpoint ID of the new server requesting the state;  
<tt>xferID</tt> identifies the state transfer transaction;  <tt>requestMsg</tt> contains 
a message from the joining server specifying which portion of the state is being requested.  

<p>
Each invocation of <tt>askState_Callback</tt> must eventually be followed by a call to 
the 
<a href="Maestro_CSX.htm#sendState"><tt>sendState</tt></a> 
function, which sends (the requested portion of) the 
state to the joining server.

<p>
<h4>
<a name="sendState"><hr>sendState</a></h4>

<pre>		void sendState(Maestro_EndpID &dest,
			       Maestro_XferID &xferID, 
			       Maestro_Message &stateMsg);</pre>

<li>This function must be eventually called after every invocation of 
<a href="Maestro_CSX.htm#askState_Callback"><tt>askState_Callback</tt></a> 
at a "normal" (old) server.  The value of the <tt>dest</tt> argument must be equal
to the value of the <tt>origin</tt> argument in the corresponding invocation of 
<tt>askState_Callback</tt>.  Similarly, the value of the <tt>xferID</tt> argument 
must be the same as that in <tt>askState_Callback</tt>.  The <tt>stateMsg</tt> argument
should contain the portion of the state requested with the corresponding invocation of
<tt>askState_Callback</tt>.

<p>
<h4>
<a name="gotState_Callback"><hr>gotState_Callback</a></h4>

<pre>		void gotState_Callback(Maestro_XferID &xferID,
				       Maestro_Message &stateMsg);</pre>

<li>This callback method is eventually invoked after a call to the
<a href="Maestro_CSX.htm#getState_nonblocking">non-blocking <tt>getState</tt></a> function,
if the requested portion of a local state has been successfully received 
from an old server.  The <tt>xferID</tt> argument identifies the state-transfer
transaction.  The <tt>stateMsg</tt> argument contains the requested
state message.

<p>
<h4>
<a name="xferCanceled_Callback"><hr>xferCanceled_Callback</a></h4>

<pre>		void xferCanceled_Callback(Maestro_XferID &xferID);</pre>

<li>This callback method is invoked after a call to the
<a href="Maestro_CSX.htm#getState_blocking">non-blocking <tt>getState</tt></a> function
if the state-transfer transaction is aborted.  The <tt>xferID</tt> argument identifies
the state-transfer trasnsaction.

<p>
<h4><a name="xferDone"><hr>xferDone</a></h4>

<pre>		void xferDone(Maestro_XferID &xferID);</pre>

<li>This method must be called by a joining server when its state transfer
has been completed. The value of the <tt>xferID</tt> argument must be equal to the
ID of the current state-transfer transaction (which is the value of <tt>xferID</tt> 
passed in the corresponding call to 
<a href="Maestro_CSX.htm#stateTransfer_Callback"><tt>stateTransfer_Callback</tt></a>).

<p>
<hr>
<address>
send mail to
<a href="mailto:alexey@cs.cornell.edu">alexey@cs.cornell.edu</a>
</address>

</body>
</html>
