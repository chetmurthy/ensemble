<!-- File: Maestro_Types.htm -->
<!-- Author: Alexey Vaysburd -->
<!-- Contents: Description of basic Maestro Types -->
<!-- Created: September 1995 -->
<!-- Updated: Feb 1997 -->

<html>

<head>
<title>Maestro Types</title>
<link rev="made" href="mailto:alexey@cs.cornell.edu (Alexey Vaysburd)">
</head>

<BODY TEXT="#000000" BGCOLOR="#FCD5AD" LINK="#0000FF" VLINK="#551A8B" ALINK="#FF0000">
<TABLE WIDTH="800" >
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH="100"><IMG SRC="maestro-logo.jpg" VSPACE=20 HSPACE=20 HEIGHT=105 WIDTH=70 ALIGN=LEFT></TD>

<TD WIDTH="500" BORDER="0">
<H1>Maestro Types</H1>
</TD>
</TR>
</TABLE>

This document is a part of online 
<a href="http://www.cs.cornell.edu/Info/Projects/Ensemble/index.htm">
Ensemble</a> documentation, under 
<a href="Maestro.htm">Maestro Open Toolkit</a>.
<hr>

<h4>Index:</h4>
<dir>

<li>Messages
	<dir>
	<br>
	<li><a href="Maestro_Types.htm#Maestro_Message">Maestro_Message</a>
	</dir>
	<p>

<li>Endpoints
	<dir>
	<br>
	<li><a href="Maestro_Types.htm#Maestro_EndpID">Maestro_EndpID</a>
	</dir>
	<p>

<li>Threads
	<dir>
	<br>
	<li><a href="Maestro_Types.htm#Maestro_Thread">Maestro_Thread</a>
	<li><a href="Maestro_Types.htm#Maestro_Semaphore">
		Maestro_Semaphore</a>
	<li><a href="Maestro_Types.htm#Maestro_Lock">Maestro_Lock</a>
	<li><a href="Maestro_Types.htm#Maestro_Barrier">Maestro_Barrier</a>
	</dir>
	<p>

<li>Miscellaneous Types
	<dir>
	<br>
	<li><a href="Maestro_Types.htm#Maestro_ErrorHandler">
		Maestro_ErrorHandler</a>
	<li><a href="Maestro_Types.htm#Maestro_Base">Maestro_Base</a>
	<li><a href="Maestro_Types.htm#Maestro_String">Maestro_String</a>
	<li><a href="Maestro_Types.htm#Maestro_OrderedSet">
	Maestro_OrderedSet</a>
	</dir>

</dir>

<p>



<h2><a name="Maestro_Message"><hr>Maestro_Message</a></h2>

<li>Communication between group members is via messages implemented with
the <tt>Maestro_Message</tt> class.  The following public methods are
provided:

<pre>	void read(int&);			// read an integer from the message
	void read(void *buf, int size);		// read a buffer from the message

	void write(int);			// write an integer into the message
	void write(void *buf, int size);	// write a buffer into the message
	
	unsigned size();			// get total size of the message
	unsigned getPos();			// get current position of message pointer
	void setPos(unsigned offset);		// set position of message pointer	
	void seek(int offset, Maestro_MsgSeek whence); // seek to the specified offset. 

	// Pack an array of messages into the given msg.
	void pack(Maestro_Message *msgs, unsigned nmsgs); 
	
	// Unpack an array of messages from the given msg.
	void unpack(Maestro_Message *&msgs, unsigned &nmsgs); 

	void reset();				// reset the message
	int isWritable();			// return non-zero iff the message is writable
</pre> 

Read/write operations on Maestro messages follow the stack paradigm 
(first in/last out).
This is convenient in the layering architecture of Maestro/Ensemble, where
layers push headers on outgoing messages and pop matching headers from incoming
messages.
 
There are also stream-like message I/O operators defined for basic types, such as <tt>int, 
<a href="Maestro_Types.htm#Maestro_EndpID">Maestro_EndpID</a>, 
<a href="Maestro_Types.htm#Maestro_EndpList">Maestro_EndpList</a>, 
<a href="Maestro_Types.htm#Maestro_String">Maestro_String</a></tt>.  
For example, consider the following code at the sender side:

<pre>	Maestro_Message msg;
	Maestro_EndpID endp;
	Maestro_EndpList elist;
	Maestro_String s("hello world");
	.......
	msg << endp << elist << s;		// push endp, elist, s into msg
	memb.cast(msg);				// multicast msg to the memb's group</pre>

This could correspond to something like this at the destination:

<pre>	receivedMsg >> s >> elist >> endp;	// pop ent, elist, s from the msg</pre>

<li>See the discussion of 
<a href="Maestro_Types.htm#Maestro_Base">
<tt>Maestro_Base</tt>
</a>
on how to define message I/O operators for subclasses of <tt>Maestro_Base</tt>.

<p>
<li>The assignment operator <tt>=</tt> can be used to make an <em>alias</em> of a message.
After the assignment, both the source message and the alias become read-only.
Aliases point to the same message buffer as the original message, however each alias 
has its own read-offset pointer.  In order to make  a writable copy of a message, 
the overloaded <tt><<=</tt> operator should be used; for example:

<pre>	Maestro_Message m1, m2, m3;
	int i, pos;
	m1 << 5;			// push an integer into m1
	pos = m1.getPos();		// remember the current offset at m1
	m1 >> i;			// pop an integer from m1
	m1.setPos(pos);			// rewind m1 (which becomes read-only)
	m2 = m1;			// make m2 an alias of m1 (m2 is read-only)
	m3 <<= m1;			// copy m1 into m3 (m3 is writable)
</pre>

<p>
<li>There is a run-time type checking for types supported by <tt>Maestro_Message</tt>, which 
can be disabled if desired (to disable, undefine <tt>MAESTRO_MESSAGE_TYPECHECKING</tt> in
the Maestro configuration file, <tt>Maestro_Config.h</tt>).

<p>
<li>Initially a message is created in the writable mode (except when the copy-from-buffer 
constructor is used).  After one the methods <tt>read(), unpack(), seek(), setPos()</tt> 
is invoked, the message becomes read-only. The <tt>reset()</tt> method can be used to 
empty a message and make it writable again.

<p><em>NOTE:  Byte ordering issues are not yet addressed in Maestro messages.</em>

<h2><a name="Maestro_EndpID"><hr>Maestro_EndpID</a></h2>

Endpoint ID's are implemented in Maestro with the <tt>Maestro_EndpID</tt> class.
The class defines stream-like message I/O and standard output operators, for example:

<pre>	Maestro_EndpID endp;
	Maestro_Message msg1, msg2;
	.....
	msg1 >> endp;			// pop endp from the message
	msg2 << endp;			// push endp onto the message
	cout << endp;			// print out the value of endp</pre> 

<h2><a name="Maestro_Thread"><hr>Maestro_Thread</a></h2>

Thread creation is supported in Maestro with the <tt>Maestro_Thread</tt> class.
The only public method of <tt>Maestro_Thread</tt> is static <tt>create</tt>, 
defined as follows:

<pre>	struct Maestro_ThreadOps { int stackSize; };

	static void create(void (*proc)(void*), 
			   void *arg,
			   Maestro_ThreadOps *ops = 0,
			   Maestro_ErrorHandler *error_handler = 0);</pre>

A call to <tt>Maestro_Thread::create(proc, arg)</tt> invokes <tt>proc(arg)</tt>
in a separate thread.  The size of the thread's stack can be adjusted with
the <tt>ops</tt> argument.

<h2><a name="Maestro_Semaphore"><hr>Maestro_Semaphore</a></h2>

<tt>Maestro_Semaphore</tt> defines two public methods, <tt>inc()</tt> and <tt>dec()</tt>.  
The default initial value of a semaphore is 0, so executing the following code will 
block the thread:

<pre>	Maestro_Semaphore sema;
	sema.dec();</pre>

<h2><a name="Maestro_Lock"><hr>Maestro_Lock</a></h2>

<tt>Maestro_Lock</tt> defines two public methods, <tt>lock</tt> and <tt>unlock</tt>.  
Initially the lock is open. For example:

<pre>	Maestro_Lock lck;
	lck.lock();			// acquire the lock
	.......
	lck.unlock();			// release the lock</pre>

<h2><a name="Maestro_Barrier"><hr>Maestro_Barrier</a></h2>

<tt>Maestro_Barrier</tt> is a specialized condition variable with the following property:  
all threads blocked on a closed barrier are released at once when the barrier 
is open.   

<p>
The public methods defined by <tt>Maestro_Barrier</tt> are <tt>open(), close(), pass(), 
isOpen(),</tt> and <tt>isClosed()</tt>.  
<p>
<li>By default, the  initial state of a barrier object is "open".  
<p>
<li>A call to <tt>pass()</tt> returns 
immediately if the barrier is open, and blocks if the barrier is closed. 
<p>
<li>When the <tt>open()</tt> method is invoked, 
the state of the barrier is set to "open", and all waiting threads are released.  
<p>
<li>When the <tt>close()</tt> method is invoked, the barrier's status becomes "closed".  

<p>
Example:

<pre>	Maestro_Barrier hb;
	hb.pass();			// doesn't block since the barrier is open
	hb.close();			// closes the barrier
	hb.pass();			// blocks until another thread calls open()</pre>

<h2><a name="Maestro_ErrorHandler"><hr>Maestro_ErrorHandler</a></h2>

Error handling is implemented in Maestro with the <tt>Maestro_ErrorHandler</tt> class.
A <tt>Maestro_ErrorHandler</tt> object can be passed as an optional parameter
to constructors of most of Maestro classes.  When a fatal error occurs, a <tt>panic()</tt>
method of the corresponding error-handler object (of either <tt>Maestro_ErrorHandler</tt> 
class or a user-defined subclass of <tt>Maestro_ErrorHandler</tt>) is invoked.
 
<tt>Maestro_ErrorHandler</tt> defines two versions of the <tt>panic</tt> method: 

<pre>		void panic(char *context);
  		void panic(hot_err_t err, char *context);</pre>

In the default implementation of <tt>panic()</tt> methods in the <tt>Maestro_ErrorHandler</tt>
class, when <tt>panic()</tt> is invoked, 
an error message is printed, after which the process is terminated.

<h2><a name="Maestro_Base"><hr>Maestro_Base</a></h2>

Most of Maestro classes are subclasses of <tt>Maestro_Base</tt>, which defines
stream-like standard output and message I/O operators.

<p>
In order to be readable/writable from/to a 
<a href="#Maestro_Message"><tt>Maestro_Message</tt></a> object, 
a subclass of <tt>Maestro_Base</tt>
must overload the following two operators:

<pre>	virtual void operator << (Maestro_Message& msg); 	// reading itself from msg
	virtual void operator >> (Maestro_Message& msg); 	// pushing itself onto msg</pre>

That is, a subclass of <tt>Maestro_Base</tt> is required to "know" how to read/write itself
from/into a message if it is to support stream-like message I/O operations. 

<p>
<li>If <tt>MAESTRO_MESSAGE_TYPECHECKING</tt> is defined (in Maestro configuration file,
 <tt>Maestro_Config.h</tt>), then message I/O operations will include run-time type checking 
based on "magic numbers".  <tt>Maestro_Base</tt> defines a <tt>messageMagic()</tt> method,
which returns the "magic number" to be pushed along with a <tt>Maestro_Base</tt> object on
an outgoing message, and checked at the destination when extracting the object from the
message.  The <tt>messageMagic()</tt> method can be overloaded for finer typechecking 
in subclasses of <tt>Maestro_Base</tt>.

<h2><a name="Maestro_String"><hr>Maestro_String</a></h2>

<tt>Maestro_String</tt> is a wrapper class for C <tt>char</tt> strings.
It defines public methods for string comparison, assignment, and stream-like standard output and
message I/O.  For example:

<pre>	Maestro_String s1;			// create an empty string

	Maestro_String s2("hello world");		
	cout << s2 << endl;			// print "hello world"

	s1 = s2;
	assert(s1 == s2);

	Maestro_String s3;			// s3 is empty
	Maestro_Message m;
	m << s1;
	m >> s3;
	assert(s1 == s3);</pre>

<h2><a name="Maestro_OrderedSet"><hr>Maestro_OrderedSet</a></h2>

<tt>Maestro_OrderedSet</tt> is a macro class, which can be used just like a template 
(but doesn't incur compilation problems of templates).  The difference from a template
implementation is mostly syntactical (see examples below).

<p><tt>Maestro_OrderedSet</tt> implements standard 
operations on ordered sets:  union, intersection, difference, and random access.   
As a subclass of 
<a href="#Maestro_Base"><tt>Maestro_Base</tt></a>, 
<tt>Maestro_OrderedSet</tt> supports stream-like 
standard output and message I/O.

<p>
<li>It is guaranteed that the order of elements in a Maestro_OrderedSet object is preserved under 
union, intersection, and difference operations.  

<li>When a new element is added to the set, it becomes the last one.  

<li>A class used in an instantiation of <tt>Maestro_OrderedSet</tt> must define the copy 
constructor and equality operator, "==".

For example:

<pre>	struct Foo {
		Foo(Foo& f) {
			key = f.key;
			value = f.value;
		}

		int operator==(Foo& f) {
			return (key == f.key);
		}
	
		int key, value;
	};

	// Note the syntax here!  Parentheses () are used
	// where the angle brackets <> would be used in a
	// template instantiation:
	typedef Maestro_OrderedSet(Foo) FooList;

	FooList L;			// creates an empty list
	assert(L.size() == 0);

	Foo f;
	f.key = 1;
	f.value = 2;
	L += f;				// add f to L
	assert(L.size() == 1);

	Foo f2;
	f2.key = 1;			// Note that f == f2
	f2.value = 3;
	FooList L2(f2);			// L2 contains one element, f2
	assert(L2.size() == 1);
	assert(L2.contains(f2)); 
	assert(L2[f2] == 0);		// index of f2 in L2 is 0
	assert(L2[0] == f2);		// f2 is the 0'th element in L2

	FooList L3(L2);			// L2 and L3 have now the same contents

	L3.clear();			// remove all elements from L3
	assert(L3.size() == 0);

	assert(f == f2);		// Note that L already contains f
	L += f2;			// f2 is *not* added to L since f == f2
	assert(L.size() == 1);

	Foo f3;
	f3.key = 5;
	f3.value = 4;
	L += f3;			// add f3 to L
	assert(L.size() == 2);

	L -= f;				// remove f from L
	assert(L.size() == 1);

	L -= f;				// can't remove same thing twice
	assert(L.size() == 1);

	L3 = L;				// now L and L3 have the same contents

	L += L2;			// L = set union of L and L2
	L -= L2;			// L = set difference of L and L2
	L &= L2;			// L = set intersection of L and L2

	FooList L4;
	L4 <<= L;			// L4 "steals" the contents of L
	assert(L.size() == 0);		// L has become empty!</pre>

There are several ordered-set types defined in Maestro, such as 
<a name="Maestro_EndpList"><tt>Maestro_EndpList</tt></a>
 and 
<a name="Maestro_MessageList"><tt>Maestro_MessageList</tt></a>.

<tt>Maestro_EndpList</tt> defines operators for message I/O and standard output,  
for example:

<pre>	Maestro_Message msg;
	Maestro_EndpID e1, e2, e3;
	Maestro_EndpList L, L2;
	L += e1;
	L += e2;
	L += e3;
	cout << L;			// print the contents of L
	msg << L;			// push L into the message
	msg >> L2;			// read the list into L2</pre>

<hr>
<address>
send mail to
<a href="mailto:alexey@cs.cornell.edu">alexey@cs.cornell.edu</a>
</address>

</body>
</html>
